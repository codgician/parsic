initSidebarItems({"fn":[["and","Combinator: `and` (function ver.)Sequential parser that applys the first parser then the second. If both parsers succeed, returns a tuple containing their results, otherwise fail."],["bind","Combinator: `bind` (function ver.)Monadic bind operator `(>>=)` for context sensitive parsing."],["compose","Combinator: `compose` (function ver.)Functional composition between parsers."],["empty","Combinator: `empty`A parser that consumes no item and always fails."],["fix","Combinator: `fix`In Rust, closures are anonymous functions, so there is no name for us to call when we want to make it recursive. Therefore, a Y-Combinator, or fixed-point combinator `fix` is introduced to address this issue, making it possible to write parsers that support recursive syntax using closures."],["left","Combinator: `left` (function ver.)"],["many","Combinator: `many` (function ver.)Apply given parser as many times as possible (zero or more times), and returns a vector `Vec<T>` containg all the parse results. The combinator always succeeds."],["map","Combinator: `map` (function ver.)Maps the result of a parser to another value using the given function."],["map_option","Combinator: `map_option` (function ver.)Maps the result of a parser to another value using the given function that produces an `Option<T>`. The only difference with `map` is that `map_option` will automatically try to unwrap the `Option<T>` and will fail if the result is `None`."],["map_result","Combinator: `map_result` (function ver.)Maps the result of a parser to another value using the given function that produces an `Result<T, E>`. The only difference with `map` is that `map_result` will automatically try to unwrap the `Result<T, E>`. If an `Err` is yeilded, `map_result` will log down the error message. Therefore, it requires `E` from `Result<T, E>` to implement `ToString` trait."],["mid","Combinator: `mid` (function ver.)"],["optional","Combinator: `optional` (function ver.)Apply given parser at most one time. Denote the result of the given parser `p` as `x`, then the result of `optional(p)` would be `Some(x)`."],["or","Combinator: `or` (function ver.)Alternative combinator. Accepts two parsers as arguments, if the first parser succeeds then its result is returned, otherwise the result of the second parser is returned."],["pure","Combinator: `pure`Injects a value into an identity parser."],["right","Combinator: `right` (function ver.)"],["some","Combinator: `some` (function ver.)Apply given parser as many times as possible (one or more times), and returns a vector `Vec<T>` containg all the parse results. The combinator fails if the parser fails at the first attempt."]],"struct":[["Fix","Data structure for `fix` combinator."]],"trait":[["BindExt","Implement `bind` combinator for `Parsable<S>`."],["ComposeExt","Implement `compose` combinator for `Parsable<S>`."],["LogExt","Implement error related combinators for `Parsable<S>`."],["MapExt","Implement `map` and related combinators for `Parsable`."],["OrExt","Implement `or` combinator for `Parsable<S>`."],["ReplicativeExt","Implement replicative combinators for `Parsable<S>`."],["SequentialExt","Implement sequential combinators for `Parsable<S>`."]]});